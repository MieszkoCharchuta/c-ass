# Topics

Multi-dimensional arrays.

# Warm-up

Implement functionality provided by the following command with the specific
options.  Just hardcode the parameter in the code, e.g.

```
#define CHAR_DO_DEL     'x'
```

See the tr(1) manual page if unsure.

## Variant 1: delete a single char (`tr -d '<char>'`)

Example:
```
$ cat /etc/passwd | tr -d r > output
$ cat /etc/passwd | ./a.out > output2
$ diff output output2
$ echo $?
0
```

## Variant 2: squeeze a single char (`tr -s "<char>"`)

Squeeze multiple occurrences of the character into one.

```
$ echo "hellooooooo, wooooooorld" | tr -s o
hello, world
```

# Common mistakes I.

I noticed several times already that you may end up doing the following:
```
#define MYDEF = 3
```

And you hit a syntax error when `MYDEF` is used later in the code.

What happens?  A preprocessor replaces occurences of `MYDEF` with whatever is
after `MYDEF`, and separated from it with a sequence of white spaces (tabs,
spaces, newlines if escaped).

In the case above, `MYDEF` will be literary replaced with "= 3".

Check with `gcc -E` (or `cpp`) which stops after the preprocessor phase (ie. it
does NOT compile anything).  The following is in :eyes:
[common-mistake-with-define.c](/src/common-mistake-with-define.c)

```C
#define MYDEF = 3

if (i < MYDEF) {
	// ...
}
```

The code above will end up in a syntax error as `i < = 3` is not a correct
expression in C (because of the space between `<` and `=`).

```
$ gcc -E common-mistake-with-define.c 
...
...

if (i < = 3) {

}
```


# Multidimensional arrays

- multi-dimensional arrays: it is an array of arrays

```C
int a[3][2] = { {0, 1}, {2, 3}, {4, 5} };
```

- `a` is an array of 3 elements.  Each of the element in an array of 2 elements.
  - we read it like that as the operator `[]`, *array subscripting*, is
    evaluated **left-to-right**.  See [operator
    precedence](/modules/operator-precedence.md) for more information.

- to access a given item all elements have to be specified in square brackets.
  i.e. `a[1, 2]` does not work, you have to use `a[1][2]`

- in memory this is stored as consequent individual "lines".  In other words,
  any array, no matter how many dimensiones it has, is stored as one piece of
  memory.

- for 3-D array it looks as follows.  `a` is an array of 2-dimensional arrays:

```C
int a[2][4][3] = {
	{ {1, 2, 3}, {4, 5, 6}, {8, 7, 8}, {9, 1, 9} },
	{ {0, 0, 0}, {1, 1, 1}, {2, 2, 3}, {4, 4, 5} },
};
```

- in memory:

```
| 1 2 3 | 4 5 6 | 8 7 8 | 9 1 9 |
| 0 0 0 | 1 1 1 | 2 2 3 | 4 4 5 |
```

:eyes: [3d-array.c](/src/3d-array.c)

- as with the 1-dimensional array, the most "significant" dimension of the array
  may be omitted **if statically initialized**, but nothing below, i.e.

```
int a[][5] = { 0 };
int a[][3][6] = { 0 };
```

are fine. However:

```
int a[5][6][] = { 0 };
int a[5][][8] = { 0 };
```

are not.

- the reason is that if you do not know how may "lines" are there, it's OK, but
  you always need to know the "length" of the "line" so that you can put them
  one by one.

- see above for `a[2][4][3]` and its memory layout.  We can easily add a new
  element of `a` which is a 2-dimensional array, but there is no way we can
  store the `a` array unless we know the exact dimensions of the 2-d subarray.

- as before, if you do not initialize the rest, it will be set as 0.  You can
  also used [designated initializers](/modules/array-intro.md) same way as with
  one-dimensional arrays.

- `sizeof` works as expected.  So, the following prints a size of of an element
  of `a`, which is an `[3][6]` subarray of integers, so `72` is printed (3 * 6 *
  sizeof (int)) unless you are on something you borrowed from the [Computer
  History Museum](https://computerhistory.org/).  If you happen to be in Silicon
  Valley, it is worth going to Mountain View to visit this one.

```C
int a[][3][6];
printf("sizeof = %zu\n", sizeof (array[0]));
```

:wrench: Define an array `[4][2]`, statically initialize it, and write a
function that accepts such an array and prints the first element from each `[2]`
subarray.

:eyes: [2d-array.c](/src/2d-array.c)

:wrench: write a program that takes a 2-D array of integers and constructs a 1-D
array of maximum values in each sub-array, then prints out the new array to the
standard output.  For the maximum value in a sub-array, write a function.

:eyes: [2d-array-max.c](/src/2d-array-max.c)

## VLA, multi-dimensional arrays, and function arguments

You can use variable-length arrays in function arguments themselves, like this:

```
int
myfn(int width, int a[][width])
{
	...
}
```

# Mountain scenery generator

:wrench: Write a simple moutain generator.  At every iteration you go either
straight (`-`), up (`/`), or down (`\`).  The program generates something like
the following:

```
$ a.out

               /                         /--
            / / \- /--                  /   \                       / /-
           / \    \   \              /--     \-                   /- \  \
          /            \            /          \             /-- /       \
      / /-              \-  /--   /-            \-          /   \         \
     / \                  \-   \ /                \-  /-- /-
    /                           \                   \-   \
 /--
-
```

**With all the variants below, try to make the code as simple as possible.** You
can do really cool stuff with quite little code.

You will need a two-dimensional array to fill, then print.  Use `memset()` to
initialize the array with spaces.  Check the man page for `memset`.  For the
first argument of `memset`, pass an array name.  Its dimension does not matter
in this case as long as you use its correct size in bytes.

For random numbers, use `rand()` and `%` for modulo.  To initialize the random
generator, use `sranddev()` if you have it, or `srand(time(NULL))`.  Check the
documentation if unsure (each function is supposed to have its manual page).

There is no language construct to initialize all elements of an array with a
specific non-zero value, that is why we need `memset`.  You can only zero it out
using an initializer `{ 0 }`, as we already know.

The algorithm goes from left to right, one character at a time. At each point it
decides whether the mountain will grow, descend or remain the same (hence the
random numbers).

Once you got a working program, refactor the code into small functions (one for
printing a character based on random number, one for printing the whole 2-D
array, etc.).  Optionally you can try to avoid global variables by passing the
array as parameter of a function.  In that case, you might try to use a VLA in
function arguments to see it works.  See [multi-dimensional
arrays](/modules/multi-dimensional-arrays.md) for more information.

:eyes: [mountain-generator.c](/src/mountain-generator.c)

## Variant: nicer mountain

You can make it more complicated and make the ascii art smoother.  For example,
you can define that after `/` you cannot go down with `\` but you could do `/\`,
etc.  You would need to keep a state of the previous character.  You could
generate something like this (use your imagination):

```
            .
           / \
          /   \__
      /\_/       \__/|
     /               |
    /                \__/............................
  _/
```

## Variant: mountain range

The top-level function (`mountain()`) can be also called with the array (and its
dimensions) as input and you can try calling it multiple times to see if a
mountain range can be generated.

## Variant: add snow caps

Usually, there is snow on the peaks.

## Variant: ???

Come up with something else.

