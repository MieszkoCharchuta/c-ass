# Pointer addressing

Like with arrays, it is possible to subscript pointers:

```C
        int a[10];
        int *p = a;

        p[0]...
```

since the same rule applies: `p[x]` is `*(p + x)`.

-------------------------------------------------------------------------------

# Array of pointers

```C
/*
 * [] is of higher precedence than *, so the following means:
 *
 *	 "a is an array of 10 pointers to char"
 */
char *a[10];
```
You can initialize it the same way as before.  Remember, a string contant is
technically an array of chars, so we can use it to initialize this array of char
pointers (same as `char *p = a`, see lecture 07 notes).
```C
char *a[] = { "hello", "world", "!" };
```
Code: :eyes: [array-of-ptrs.c](src/array-of-ptrs.c)

:wrench: task: define two integers i, j and initialize them with some arbitrary
values.  define an array `a` of pointers to `int`s that will contain pointers
to these two integers.  define an array `b` of `int`s that will contain the values
of these two integers.  define a pointer `p`, and assign i-th element of array
`a` to it.  Define a pointer `q`, and assign an address of the i-th element of
array `b` to it.  Print the address of `p`, `q` and then deference them.

What you are expected to get when dereferencing the `p` and `q` pointers?

What is the distance between these 2 pointers?  Does it make sense to do that?

What is a reasonable value of the 1st argument (`i`)?

usage: `./a.out <i>`

Code: :eyes: [ptr-to-array-of-ptrs.c](src/ptr-to-array-of-ptrs.c)

-------------------------------------------------------------------------------

# Pointer to a pointer

We know that a pointer points to an object (unless its a `NULL` pointer or of
type `void`), eg. an `int`.  However, the object can be another address, i.e.
another pointer.

```C
int i = 13;
int *pi = &i;
int **ppi = &pi;	// ppi is a pointer to a pointer to an int

// *pi is a pointer to an int, so another dereference is needed to get the value
printf("%d\n", **pi);	// prints 13
```

## A pointer to a pointer to an array vs. a pointer to an array of pointers

Imagine this situation: let's assume we have an array of pointers to an integer.
A function takes a pointer to a pointer to an integer and dereferences the
array's n-th element, i.e.:

```C
void
foo(int **p, size_t idx)
{
	printf("%d\n", *(*p + idx));
}
```

Clearly, this works fine in a situation when `pp` is indeed a pointer to an
array of integer pointers (left).  Now what if someone passes a pointer to a
pointer to an integer (right)?

	  +----------+      +----------+
	i |    42    |    j |    7     |
	  +----------+      +----------+
	        ^            /
	        |          /
	   +----------+----------+		+----------+----------+
	 a |          |          |	      b |     42   |    7     |
	   +----------+----------+		+----------+----------+
	         ^				      ^
	         |				      |
	    +----------+			+----------+
	ppa |	       |		     pb |	   |
	    +----------+			+----------+
	  					      ^
						      |
						 +----------+
	  				     ppb |	    |
						 +----------+

What is the difference in accessing the values ? I.e. what will `**(x + 1)` and
`*(*x + 1)` do when `x` is `ppa` or `ppb`?

Code: :eyes: [ptr-ptr-array.c](src/ptr-ptr-array.c)

This is from a real-life problem, quoting from https://unixpapa.com/incnote/pam.html:

> When the conversation function is called, it is passed an array of prompts.
> This is always passed in as struct pam_message `**mesg`. However, the
> interpretation varies. In Linux-PAM and OpenPAM this is a pointer to an array
> of pointers to pam_message structures, whereas in Solaris it is a pointer to a
> pointer to an array of pam_message structures. Frequently there is only one
> prompt being passed in, so it doesn't matter. Under either interpretation, the
> first structure is addressable as `**msg`. However, accessing subsequent
> elements is different. In Linux-PAM and OpenPAM, the second element is at
> `*(msg[2])`, while in Solaris it is at `(*msg)[2]`.

# Changing pointers

  - in order to change the value of a pointer in a function, it has to be
    passed as a pointer to a pointer
    - this makes sense, because the storage address of a plain pointer is not
      known to the function, and therefore we must pass in its address so that
      we can change the object the address points to by dereferencing the
      address.

Code: :eyes: [ptr-change.c](src/ptr-change.c)

-------------------------------------------------------------------------------

# heap/dynamic allocation: malloc()/free()

The memory automatically allocated for local variables and function parameters
is allocated in an area called a stack. There is an area called a heap to
allocate memory that lasts after the function returns. This is also called
dynamic allocation.

The allocator in the standard library offers the malloc()/calloc()/free()/...
APIs for heap allocation.

The malloc/calloc functions return a pointer to a memory area of a specified
size or NULL pointer if the allocation failed - always check that!  (even on
Linux where it seems it can never fail - to be prepared for change in a
configuration and also for portability to systems with more conservative memory
allocation)

## Memory leaks

The C runtime system does not have a garbage collector so all heap allocated
memory has to be explicitly freed via `free()` after it is no longer needed.  If
not freed, that creates a resource leak called a *memory leak*. Depending on the
problem this might cause the problem of running out of memory later on (and then
malloc/calloc can start returning `NULL`).

The leaks can be checked using static or dynamic analyzers.

Task: write a program that takes all arguments that follow `argv[0]`,
concatenates them (without the terminating `NUL` character) into one
(dynamically allocated via malloc()) string and prints this string to the
standard output.
      - the concatenation can be done either by hand (try that first) or
	strncat() (try that afterwards)

Code: :eyes: [argv-concat.c](src/argv-concat.c)
