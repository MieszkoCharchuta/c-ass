# Recap

- a string literal is an expression whose value is an address of the 1st
  character of the string
- a pointer to a string literal can be changed, however the value of the string
  is read-only
- an address of a character array initialized with a string cannot be changed,
  the contents can be
- explicit casting works however beware of alignment issues
- no need to cast when working with `void *`
- there are 2 storage classes - *automatic* and *static*, a variable can be
  either `auto` (that is a keyword but as it represents the default class, it is
  never really used) or `static`.
- storage expresses lifetime, static variables can be initialized just once
- global variables are always static

# Unions

- similar to structures however have different semantics
	- stores its members in the same memory location
	- allows for different "views" of the same data
- usually combined with structures
- handy for efficient data storage or HW programming

consider this declaration:
```C
union foo {
	unsigned short i; // 2 bytes
	struct {
		unsigned char low;
		unsigned char high;
	} bytes;
};
```
  - the `sizeof(union foo)` will be that of its largest member
  - modify a value of `i` and it will be reflected in the low/high values
    because `i` and `bytes` share the same location

```
		0             high memory addresses
		+-------------+
		|      i      |
		+-------------+
		| low  | high |
                +-------------+
```

- union can be part of a structure, see :eyes:
  [union-in-struct.c](src/union-in-struct.c)
- union can be "anonymous" (e.g. no name inside of a structure), however this is
  non-standard just like for structures

:wrench: Task: use the above declaration to find out if the program is running
on big or little endian system (least significant byte is stored on lowest
address). The program will print either "big endian" or "little endian" to
standard output.

:eyes: code: [union-lowhigh.c](src/union-lowhigh.c)

# Home assignment

:wrench: implement a command line parser ala getopt(3). The global variable
'myoptarg' will be set if an option has an argument.

Note: call the function `mygetopt()` not to intermingle with the standard
library's `getopt()`.  Implement the "POSIXly correct solution", i.e. stop once
non-option argument is encountered (i.e. one not starting with `-`) or after the
`--` option is reached.

:wrench: bonus task: implement myoptind/myopterr/myoptopt

See the following code on how to use getopt(3):

https://github.com/devnull-cz/unix-linux-prog-in-c-src/blob/master/getopt/getopt.c

:wrench: implement

```C
      char *strsepc(char **stringp, int c);
```

which behaves like strsep(3) except that it searches only for the first
occurence of single character.

:eyes: code: [strsepc.c](src/strsepc.c)
